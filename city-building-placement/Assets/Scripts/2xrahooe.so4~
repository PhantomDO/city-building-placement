using System;
using UnityEngine;

namespace Assets.Scripts
{
    [Serializable]
    public struct MeshProperties
    {
        public Matrix4x4 mat;
        public Vector4 color;

        public static int Size()
        {
            return sizeof(float) * 4 * 4 + sizeof(float) * 4;
        }
    }

    [RequireComponent(typeof(CityBuild))]
    public class CityRenderer : MonoBehaviour
    {
        [SerializeField] private CityBuild _builder;
        
        public Material material;
        public ComputeShader computeShader;
        private ComputeBuffer _meshPropertiesBuffer;
        private ComputeBuffer _argsBuffer;

        public Mesh mesh;
        private Bounds _bounds;

        #region Unity

        private void Awake()
        {
            _builder = GetComponent<CityBuild>();
        }

        public void Start()
        {
            Setup();
        }

        public void Update()
        {
            int kernel = computeShader.FindKernel("CSMain");
            computeShader.Dispatch(kernel, Mathf.CeilToInt((_builder.DimensionSize * _builder.DimensionSize) / 64f), 1, 1);
            Graphics.DrawMeshInstancedIndirect(mesh, 0, material, _bounds, _argsBuffer);
        }

        public void OnDisable()
        {
            if (_meshPropertiesBuffer != null)
            {
                _meshPropertiesBuffer.Release();
            }
            _meshPropertiesBuffer = null;

            if (_argsBuffer != null)
            {
                _argsBuffer.Release();
            }
            _argsBuffer = null;
        }

        #endregion

        public void Setup()
        {
            if (mesh == null)
            {
                mesh = CreateCube();
            }

            _bounds = new Bounds(transform.position, Vector3.one);
            InitializeBuffers();
        }

        public void InitializeBuffers()
        {
            int kernel = computeShader.FindKernel("CSMain");

            uint[] args = new uint[5] {0, 0, 0, 0, 0};

            // 0 = count of triangles indices
            // 1 = population
            // other when submeshes 
            Mesh mesh = CreateCube();
            args[0] = (uint) mesh.GetIndexCount(0);
            args[1] = (uint) (_builder.DimensionSize * _builder.DimensionSize);
            args[2] = (uint) mesh.GetIndexStart(0);
            args[3] = (uint) mesh.GetBaseVertex(0);

            _argsBuffer = new ComputeBuffer(1, args.Length * sizeof(uint), ComputeBufferType.IndirectArguments);
            _argsBuffer.SetData(args);

            // Init buffer with grid
            MeshProperties[] properties = new MeshProperties[_builder.DimensionSize * _builder.DimensionSize];
            for (int y = 0; y < _builder.DimensionSize; y++)
            {
                for (int x = 0; x < _builder.DimensionSize; x++)
                {
                    MeshProperties props = new MeshProperties();
                    Vector3 position = new Vector3(x, y, 0);
                    Quaternion rotation = Quaternion.identity;
                    Vector3 scale = Vector3.one;

                    props.mat = Matrix4x4.TRS(position, rotation, scale);
                    props.color = Color.white;
                }
            }

            _meshPropertiesBuffer = new ComputeBuffer((int)(_builder.DimensionSize * _builder.DimensionSize), MeshProperties.Size());
            _meshPropertiesBuffer.SetData(properties);

            computeShader.SetBuffer(kernel, "_Properties", _meshPropertiesBuffer);
            material.SetBuffer("_Properties", _meshPropertiesBuffer);
        }

        public Mesh CreateCube(float width = 1f, float height = 1f, float depth = 1f)
        {
            var mesh = new Mesh();
            float w = width * .5f;
            float h = height * .5f;
            float d = depth * .5f;

            var vertices = new Vector3[]
            {
                new Vector3(-w, -h, -d),
                new Vector3(-w, h, -d),
                new Vector3(w, h, -d),
                new Vector3(w, -h, -d),
                new Vector3(-w, -h, d),
                new Vector3(-w, h, d),
                new Vector3(w, h, d),
                new Vector3(w, -h, d)
            };

            var triangles = new int[]
            {
                0,1,2,
                0,2,3,

                1,5,6,
                6,2,1,

                7,4,0,
                3,7,0,

                4,5,0,
                5,1,0,

                2,6,7,
                7,3,2,

                6,5,4,
                7,6,4
            };

            mesh.Clear();
            mesh.vertices = vertices;
            mesh.triangles = triangles;
            mesh.RecalculateNormals();
            mesh.RecalculateTangents();
            mesh.RecalculateBounds();

            return mesh;
        }
    }
}